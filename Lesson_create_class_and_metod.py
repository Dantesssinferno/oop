"""
Привет Друзья!

В данной лекции мы с Вами научимся писать автотесты, используя принципы ООП.

Существует три подхода в написании автотестов использую ООП:

1)1 модуль (файл с расширением.py) - 1 тест. Вся логика и необходимые элементы включены в него

2)1 модуль (файл с расширением.py) - 1 тест + вспомогательные модули, которые используются и в других тестах 
(например модуль по авторизации пользователя в системе)

3)Полноценный проект по автоматизации, с использованием принципов POM (Page Object Model)

 

В данной лекции рассмотрим первый подход. Он предполагает, что открытие браузера, логика теста 
(шаги) и локаторы находятся в одном модуле (файле).

 

from selenium import webdriver
from selenium.webdriver.chrome.service import Service as ChromeService
from webdriver_manager.chrome import ChromeDriverManager

class TestBuyProduct():
    Класс включающий сценарий покупки товара


    def test_buy_product():
        Тест по покупке товара включает:
         в себя авторизацию, выбор товара, заполнение данных получателя, подтверждение покупки.

        # driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()))
        # driver.get("https://www.saucedemo.com/")
        # driver.maximize_window()
        #
        # ввод Логина
        # ввод Пароля
        # клик для входа в систему
        #
        # выбор товара
        # проверка товара в корзине
        # .......
        # подтверждение успешной покупки
        #
        # закрытие браузера



# start_test = TestBuyProduct() # Создание экземпляра класса
# start_test.test_buy_product() # Вызов метода с тестом
#
#
# Как Мы видим, тест состоит из следующих шагов:
#
# 1)Привычное импортирование необходимых нам библиотек и моделей;
#
# 2)Далее создается общий класс, который будет содержать метод для работы в данном тесте;
#
# 3)Создается метод, содержащий создание driver, открытие браузера по требуемой url;
#
# 4)Перечисляются шаги теста;
#
# 5)Закрываем браузер;
#
# 6)Создаем экземпляр класса и вызываем его метод;

 

#Так же в наш тест, Мы можем включить в него несколько проверок, например:

#class TestAuthentification():
   # Класс включающий сценарий о проверке авторизации в системе


    #def тест_успешная_авторизация(): #корректные данные для входа
        #открытие браузера и требуемой url
        #...........................
        #закрытие браузера

    #def тест_негативный_авторизация_1(): #некорректный логин
        #открытие браузера и требуемой url
        #...........................
        #закрытие браузера

    #def тест_негативный_авторизация_2(): #некорректный пароль
        #открытие браузера и требуемой url
        #...........................
        #закрытие браузера

    #def тест_негативный_авторизация_3(): #пустые поля
        #открытие браузера и требуемой url
        #...........................
        #закрытие браузреа

#start_test = TestAuthentification()
#start_test.тест_успешная_авторизация() #успешная авторизация, используя корректные данные
#start_test.тест_негативный_авторизация_1() #неуспешная авторизация, используя некорректный логин
#start_test.тест_негативный_авторизация_2() #неуспешная авторизация, используя некорректный пароль
#start_test.тест_негативный_авторизация_3() #неуспешная авторизация, используя пустые поля

                  
Тем самым, каждый наш метод - это самостоятельная проверка, которую Мы можем включать в наше тестирование или отключать,
просто закомментировав ненужный метод в месте его вызова. Данный способ может хорошо отработать, когда Вы пришли на
проект, в котором уже есть автоматизация, но она написана не как полноценный проект,  а каждый тест написан в одном
модуле и руководство Вам отказывает в свободном времени, для приведения проекта в правильный вид. Вы можете
использовать несколько сценариев, объединив их по одному функционалу, в одном модуле. Создать один тест, вместо четырех.

Так же данный подход можно доработать и к примеру вынести  открытие браузера и закрытие браузера отдельно от методов,
перед тестами, то есть у нас не будет каждый раз открываться и закрываться наш браузер, затрачивая на это время и
ресурсы, но у данного способа есть минус, это то, что каждый раз когда Мы заходим в нашу систему, то мы делаем это
инкогнито и наши действия не влияют на последующие сценарии, а при условии "незакрывающегося браузера"
(ждущего пока пройдут все сценарии), Мы можем получить наложение сценариев, например сообщения об ошибках и т.д.

Здесь необходимо ориентироваться по ситуации, зависимости от особенностей Вашего проекта и сценария."""
