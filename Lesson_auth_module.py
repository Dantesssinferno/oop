"""
Привет Друзья!

В данной лекции мы с Вами продолжим учиться писать автотесты, используя принципы ООП.

Существует три подхода в написании автотестов использую ООП:

1)1 модуль (файл с расширением.py) - 1 тест. Вся логика и необходимые элементы включены в него

2)1 модуль (файл с расширением.py) - 1 тест + вспомогательные модули, которые используются и в других тестах
(например модуль по авторизации пользователя в системе)

3)Полноценный проект по автоматизации, с использованием принципов POM (Page Object Model)



В данной лекции рассмотрим второй подход. Он предполагает, что логика теста (шаги) находятся в одном модуле (файле),
а в другие модули выносятся различные проверочные и вспомогательные методы, а также методы, которые повторяются в
других тестах.

Логика тестов может включать в себя авторизацию в системе. Например, Мы можем зайти на сайт интернет магазина и
посмотреть информацию о товаре, но для того чтобы его пробрести, нам необходимо произвести авторизацию в системе.
Следовательно, в одних сценариях нам необходимо это делать, а в других нет. И для того, чтобы не прописывать в каждом
сценарии, где она нужна, действия по вводу логина и пароля, Мы можем вынести ее в отдельный метод. Так же в данном
подходе есть огромный плюс - это то, что в случае изменения локаторов формы авторизации, нам не нужно менять их в
каждом тесте, Мы будем это делать только в одном модуле. Что я имею ввиду, представим, что у нас есть 100 автотестов,
и в каждом Мы выполняем авторизацию. Которая имеет вид:

user_name = driver.find_element(By.XPATH, "//input[@id='user-name']")

user_name.send_keys('standard_user')

print('Input Login')

password = driver.find_element(By.XPATH, "//input[@id='password']")

password.send_keys('secret_sauce')

print('Input Login')

button_login = driver.find_element(By.XPATH, "//input[@id='login-button']")

button_login.ckick()

print('Click Login Button')




А  теперь представим, что разработчики изменили локатор поля для ввода Логина,

с //input[@id='user-name'] на //input[@id='login']

И как результат, при прогоне наших тестов, они все "упадут". И в данной ситуации, самое обидное, это то,
что разработчики могут об этом не предупредить и прогон наших тестов, со 100-% падением наших тестов будет
для Нас сюрпризом.

Для того, чтобы этого избежать, Мы можем вынести шаги по авторизации в отдельный модуль, и тогда, если такое
произойдет, Нам не придется менять локатор поля Логин в каждом тесте, Мы сделаем это в одном едином месте.

Создадим новый модуль, который назовем login_page.py и перенесем в него часть кода из предыдущего урока.

login_page.py

from selenium import webdriver
from selenium.webdriver.chrome.service import Service as ChromeService
from webdriver_manager.chrome import ChromeDriverManager

class LoginPage():
    ""Класс включающий действия по авторизации в системе""

    def __init__(self, driver):
        self.driver = driver

    def test_authorisation(self, логин, пароль):
        ""Успешная авторизация в системе""

        driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()))
        driver.get("https://www.saucedemo.com/")
        driver.maximize_window()

        ввод Логина
        ввод Пароля
        клик для входа в систему


В нем Мы создаем новый класс LoginPage(), данный класс будет включать в себя методы по авторизации в системе,
здесь Мы можем создать метод, который уже будет включать заранее введенный логин и пароль, тестового пользователя,
который будет работать для большинства наших тестов, а так же можем создать метод который будет принимать
эти значения и уже указывать их в модуле с тестом.

Для чего необходимо использовать разных тестовых пользователей в тестах? Дело в том, что в продукте,
который Вы будете тестировать, у пользователей могут быть разные права, например один будет менеджером,
другой старшим специалистом, третий руководителем отдела, и каждый из них может иметь особый доступ к
функционалу и тем действиям которые они могут производить. Например, согласование заявок.

Второй модуль, который содержит логику нашего теста - test_buy_product.py, будет выглядеть следующим образом:

test_buy_product.py

from selenium import webdriver
from selenium.webdriver.chrome.service import Service as ChromeService
from webdriver_manager.chrome import ChromeDriverManager
from login_page import LoginPage # Импортирование класса LoginPage

class TestPuyProduct():
    ""Класс включающий сценарий покупки товара""


    def test_buy_product(self):
        ""Тест по покупке товара включает:
         в себя авторизацию, выбор товара, заполнение данных получателя, подтверждение покупки.""

        логин = "standard_user"
        пароль = "password"

        login = Login_page()
        login.authorisation(логин, пароль) #вызов метода по авторизации

        выбор товара
        проверка товара в корзине
        .......
        подтверждение успешной покупки

        закрытие браузера



start_test = TestBuyProduct # Создание экземпляра класса
start_test.test_buy_product() # Вызов метода с тестом




Написав новый модуль по авторизации, Мы можем использовать и в других тестах, например написать тест,
который будет проверять фильтрацию товара на странице:

test_filter_product.py

from selenium import webdriver
from selenium.webdriver.chrome.service import Service as ChromeService
from webdriver_manager.chrome import ChromeDriverManager
from login_page import LoginPage # Импортирование класса Login_page

class TestFilterProduct():
    ""Класс включающий сценарий покупки товара""


    def test_filter_product(self):
        ""Тест по фильтрации товара в каталоге:
         в себя авторизацию, установка фильтра по цене товара.""

        логин = "standard_user"
        пароль = "password"

        login = Login_page()
        login.authorisation(логин, пароль) #вызов метода по авторизации

        установка фильтра по цене: по возрастанию
        проверка корректной фильтрации товара

        установка фильтра по цене: по убыванию
        проверка корректной фильтрации товара

        закрытие браузера

start_test = TestFilterProduct # Создание экземпляра класса
start_test.test_filter_product() # Вызов метода с тестом


Теперь можно составлять тесты для проекта и использовать новый модуль по авторизации.
"""